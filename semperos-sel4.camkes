/*
 * semperos-sel4.camkes -- CAmkES assembly for SemperOS on seL4
 *
 * Architecture:
 *   - VDTUService:    Virtual DTU control plane (endpoint configuration)
 *   - SemperKernel:   SemperOS kernel instance (kid=0)
 *   - VPE0:           Application VPE (test harness, PE 2)
 *   - VPE1:           Second VPE (passive, PE 3) — Task 06 EXCHANGE target
 *   - DTUBridge:      E1000 + lwIP UDP bridge for inter-node DTU messages
 *
 * Connection types:
 *   1. seL4RPCCall:     Config RPC (SemperKernel -> VDTUService)
 *   2. seL4SharedData:  Message ring buffers (point-to-point: kernel <-> VPEs)
 *   3. seL4Notification: Doorbell signaling for message arrival
 *   4. seL4RPCCall:     Net RPC (SemperKernel -> DTUBridge)
 *   5. seL4HardwareMMIO/Interrupt/IOPort: E1000 NIC hardware
 *
 * Inter-node transport:
 *   DTUBridge owns the Intel 82540EM (e1000) NIC via MMIO + PCI config
 *   I/O ports. It runs lwIP (UDP-only) and exposes a DTUNetIPC RPC
 *   interface to SemperKernel. Remote PE messages (PE >= 4) are routed
 *   via this bridge as raw DTU messages in UDP datagrams on port 7654.
 */

import <std_connector.camkes>;

/*
 * =========================================================================
 *  Procedure Interfaces
 * =========================================================================
 */

/* vDTU config interface */
procedure VDTUConfig {
    int config_send(in int target_pe, in int ep_id,
                    in int dest_pe, in int dest_ep, in int dest_vpe,
                    in int msg_size, in uint64_t label, in int credits);
    int config_recv(in int target_pe, in int ep_id,
                    in int buf_order, in int msg_order, in int flags);
    int config_mem(in int target_pe, in int ep_id,
                   in int dest_pe, in uint64_t addr, in uint64_t size,
                   in int dest_vpe, in int perm);
    int invalidate_ep(in int target_pe, in int ep_id);
    int invalidate_eps(in int target_pe, in int first_ep);
    int set_vpe_id(in int target_pe, in int vpe_id);
    int set_privilege(in int target_pe, in int priv);
    int wakeup_pe(in int target_pe);
    int get_ep_count();
};

/* DTU network bridge interface: SemperKernel -> DTUBridge */
procedure DTUNetIPC {
    int net_send(in int dest_node, in int msg_len);
};

/*
 * =========================================================================
 *  Hardware Component Definitions (E1000 NIC)
 * =========================================================================
 */

component HWEthDriver {
    hardware;
    dataport Buf(0x20000) mmio;
    emits IRQ irq;
}

component HWPCIConfig {
    hardware;
    provides IOPort pci_config;
}

/*
 * =========================================================================
 *  Component Definitions
 * =========================================================================
 */

component VDTUService {
    control;

    /* Config RPC: served to SemperKernel */
    provides VDTUConfig config;

    /*
     * The vDTU is control plane only. It does NOT have dataport access to
     * message channels or memory endpoints. It maintains an in-memory
     * endpoint table mapping (pe, ep) -> channel_index. The actual shared
     * memory is point-to-point between kernel and VPE0.
     */

    /* Control plane notifications: vDTU can wake kernel or VPE0 (wakeup_pe) */
    emits    Signal notify_kernel;
    emits    Signal notify_vpe0;

    /* Kernel signals vDTU when done (for coordination) */
    consumes Signal kernel_done;
}

component SemperKernel {
    control;

    /* Config RPC: calls vDTU to set up endpoints */
    uses VDTUConfig vdtu;

    /* Pre-allocated message channel dataports (shared with VPE0) */
    dataport Buf(4096) msgchan_kv_0;
    dataport Buf(4096) msgchan_kv_1;
    dataport Buf(4096) msgchan_kv_2;
    dataport Buf(4096) msgchan_kv_3;
    dataport Buf(4096) msgchan_kv_4;
    dataport Buf(4096) msgchan_kv_5;
    dataport Buf(4096) msgchan_kv_6;
    dataport Buf(4096) msgchan_kv_7;

    /* Pre-allocated memory endpoint dataports */
    dataport Buf(4096) memep_kv_0;
    dataport Buf(4096) memep_kv_1;
    dataport Buf(4096) memep_kv_2;
    dataport Buf(4096) memep_kv_3;

    /* Control plane: vDTU can wake kernel (for wakeup_pe) */
    consumes Signal vdtu_wakeup;

    /* Control plane: kernel signals vDTU when done */
    emits    Signal kernel_done;

    /* Data path: kernel signals VPE0 that a message is available */
    emits    Signal signal_vpe0;

    /* Data path: VPE0 signals kernel that a reply is available */
    consumes Signal signal_from_vpe0;

    /* Network bridge: kernel sends remote DTU messages via RPC */
    uses DTUNetIPC net;

    /* Network bridge dataports: kernel <-> DTUBridge */
    dataport Buf(8192) dtu_out;       /* kernel writes outgoing DTU msg */
    dataport Buf(8192) dtu_in;        /* bridge writes incoming DTU msg */

    /* Network bridge: incoming message notification */
    consumes Signal net_msg_arrived;

    /* Network ring buffers: kernel <-> DTUBridge (07e) */
    dataport Buf(4096) net_outbound;    /* kernel writes, bridge reads */
    dataport Buf(4096) net_inbound;     /* bridge writes, kernel reads */
}

component VPE0 {
    control;

    /* Pre-allocated message channel dataports (shared with SemperKernel) */
    dataport Buf(4096) msgchan_kv_0;
    dataport Buf(4096) msgchan_kv_1;
    dataport Buf(4096) msgchan_kv_2;
    dataport Buf(4096) msgchan_kv_3;
    dataport Buf(4096) msgchan_kv_4;
    dataport Buf(4096) msgchan_kv_5;
    dataport Buf(4096) msgchan_kv_6;
    dataport Buf(4096) msgchan_kv_7;

    /* Pre-allocated memory endpoint dataports */
    dataport Buf(4096) memep_kv_0;
    dataport Buf(4096) memep_kv_1;
    dataport Buf(4096) memep_kv_2;
    dataport Buf(4096) memep_kv_3;

    /* Control plane: vDTU can wake VPE0 (for wakeup_pe) */
    consumes Signal vdtu_wakeup;

    /* Data path: kernel signals VPE0 that a message is available */
    consumes Signal signal_from_kernel;

    /* Data path: VPE0 signals kernel that a reply is available */
    emits    Signal signal_kernel;
}

/*
 * VPE1: Passive VPE for EXCHANGE syscall testing (Task 06).
 * VPE1's CapTable is manipulated directly by the kernel during EXCHANGE.
 * No shared data channels needed — VPE1 doesn't send/receive messages.
 */
component VPE1 {
    control;
}

/*
 * DTUBridge: E1000 + lwIP UDP bridge for inter-node DTU messages.
 * Owns the Intel 82540EM NIC hardware and runs lwIP (UDP-only).
 * SemperKernel calls net_send() RPC to transmit DTU messages to remote node.
 * Incoming UDP packets are deposited in dtu_in dataport + notification.
 */
component DTUBridge {
    control;

    /* E1000 hardware interfaces */
    dataport Buf(0x20000) eth_mmio;
    consumes IRQ eth_irq;
    uses IOPort pci_config;

    /* RPC from SemperKernel: outgoing DTU messages */
    provides DTUNetIPC net;

    /* Shared dataports for DTU message buffers */
    dataport Buf(8192) dtu_out;       /* kernel writes here before net_send() */
    dataport Buf(8192) dtu_in;        /* bridge writes incoming msg here */

    /* Notification: bridge -> kernel ("DTU message arrived from network") */
    emits Signal net_msg_ready;

    /* Network ring buffers: kernel <-> DTUBridge (07e) */
    dataport Buf(4096) net_outbound;    /* kernel writes, bridge reads */
    dataport Buf(4096) net_inbound;     /* bridge writes, kernel reads */
}

/*
 * =========================================================================
 *  Assembly: wire everything together
 * =========================================================================
 */

assembly {
    composition {
        component VDTUService   vdtu;
        component SemperKernel  kernel0;
        component VPE0          vpe0;
        component VPE1          vpe1;
        component HWEthDriver   eth_hardware;
        component HWPCIConfig   pci_hardware;
        component DTUBridge     dtu_bridge;

        /*
         * Config RPC: kernel0 -> vdtu
         */
        connection seL4RPCCall config_rpc(from kernel0.vdtu, to vdtu.config);

        /*
         * Message channel dataports: kernel0 <-> vpe0 (point-to-point).
         * Each connection allocates one set of physical pages shared
         * between exactly two components. The vDTU does NOT access these.
         */
        connection seL4SharedData msgchan0(from kernel0.msgchan_kv_0,
                                           to vpe0.msgchan_kv_0);
        connection seL4SharedData msgchan1(from kernel0.msgchan_kv_1,
                                           to vpe0.msgchan_kv_1);
        connection seL4SharedData msgchan2(from kernel0.msgchan_kv_2,
                                           to vpe0.msgchan_kv_2);
        connection seL4SharedData msgchan3(from kernel0.msgchan_kv_3,
                                           to vpe0.msgchan_kv_3);
        connection seL4SharedData msgchan4(from kernel0.msgchan_kv_4,
                                           to vpe0.msgchan_kv_4);
        connection seL4SharedData msgchan5(from kernel0.msgchan_kv_5,
                                           to vpe0.msgchan_kv_5);
        connection seL4SharedData msgchan6(from kernel0.msgchan_kv_6,
                                           to vpe0.msgchan_kv_6);
        connection seL4SharedData msgchan7(from kernel0.msgchan_kv_7,
                                           to vpe0.msgchan_kv_7);

        /* Memory endpoint dataports: kernel0 <-> vpe0 */
        connection seL4SharedData memep0(from kernel0.memep_kv_0,
                                         to vpe0.memep_kv_0);
        connection seL4SharedData memep1(from kernel0.memep_kv_1,
                                         to vpe0.memep_kv_1);
        connection seL4SharedData memep2(from kernel0.memep_kv_2,
                                         to vpe0.memep_kv_2);
        connection seL4SharedData memep3(from kernel0.memep_kv_3,
                                         to vpe0.memep_kv_3);

        /*
         * Control plane notifications: vDTU -> kernel, vDTU -> VPE0
         * Used by wakeup_pe() to wake a PE from seL4_Wait().
         */
        connection seL4Notification vdtu_wake_kern(from vdtu.notify_kernel,
                                                    to kernel0.vdtu_wakeup);
        connection seL4Notification vdtu_wake_vpe0(from vdtu.notify_vpe0,
                                                    to vpe0.vdtu_wakeup);
        connection seL4Notification kern_done(from kernel0.kernel_done,
                                              to vdtu.kernel_done);

        /*
         * Data path notifications: kernel <-> VPE0 (direct, no vDTU)
         * The sender signals the receiver after writing to the ring buffer.
         */
        connection seL4Notification kern_to_vpe0(from kernel0.signal_vpe0,
                                                  to vpe0.signal_from_kernel);
        connection seL4Notification vpe0_to_kern(from vpe0.signal_kernel,
                                                  to kernel0.signal_from_vpe0);

        /*
         * DTUBridge: E1000 hardware + network transport
         */
        connection seL4HardwareMMIO eth_mmio_conn(from dtu_bridge.eth_mmio,
                                                   to eth_hardware.mmio);
        connection seL4HardwareInterrupt eth_irq_conn(from eth_hardware.irq,
                                                       to dtu_bridge.eth_irq);
        connection seL4HardwareIOPort pci_config_conn(from dtu_bridge.pci_config,
                                                       to pci_hardware.pci_config);

        /* RPC: kernel sends outgoing DTU messages to bridge */
        connection seL4RPCCall net_rpc(from kernel0.net, to dtu_bridge.net);

        /* Shared dataports for DTU message buffers */
        connection seL4SharedData dtu_out_dp(from kernel0.dtu_out,
                                              to dtu_bridge.dtu_out);
        connection seL4SharedData dtu_in_dp(from dtu_bridge.dtu_in,
                                             to kernel0.dtu_in);

        /* Notification: bridge wakes kernel on incoming network message */
        connection seL4Notification net_to_kern(from dtu_bridge.net_msg_ready,
                                                 to kernel0.net_msg_arrived);

        /* Ring buffer dataports for network message transport (07e) */
        connection seL4SharedData net_outbound_dp(from kernel0.net_outbound,
                                                    to dtu_bridge.net_outbound);
        connection seL4SharedData net_inbound_dp(from dtu_bridge.net_inbound,
                                                   to kernel0.net_inbound);
    }

    configuration {
        /* vDTU runs at highest priority (handles config RPCs promptly) */
        vdtu.priority = 250;
        /* SemperKernel gets PE ID 0 — needs large stack for revocation + logging */
        kernel0.priority = 200;
        kernel0._stack_size = 131072;  /* 128 KiB stack for cross-VPE revocation */
        /* VPE0 gets PE ID 2 — same priority as kernel for seL4_Yield() scheduling */
        vpe0.priority = 200;
        /* VPE1 gets PE ID 3 — passive EXCHANGE target, same priority for seL4_Yield() */
        vpe1.priority = 200;
        /* VPE1 is passive — minimal heap (default 4 MiB would exhaust untyped memory) */
        vpe1._heap_size = 4096;

        /* DTUBridge: E1000 + lwIP UDP bridge */
        dtu_bridge.priority = 200;
        dtu_bridge._stack_size = 0x100000;  /* 1 MiB (e1000 init + lwIP) */
        dtu_bridge.heap_size = 0x100000;    /* 1 MiB */

        /* DMA pool for e1000 descriptor rings + buffers */
        dtu_bridge.dma_pool = 0x200000;         /* 2 MiB */
        dtu_bridge.dma_pool_paddr = 0x4000000;  /* 64 MiB offset */
        dtu_bridge.simple_untyped21_pool = 4;
        dtu_bridge.cnode_size_bits = 18;

        /* MMIO must be uncached for device register access */
        dtu_bridge.eth_mmio_hardware_cached = false;

        /* E1000 hardware config (Intel 82540EM on QEMU q35) */
        eth_hardware.mmio_paddr = 0xfeb80000;
        eth_hardware.mmio_size = 0x20000;
        eth_hardware.irq_irq_type = "pci";
        eth_hardware.irq_irq_ioapic = 0;
        eth_hardware.irq_irq_ioapic_pin = 11;
        eth_hardware.irq_irq_vector = 11;
        pci_hardware.pci_config_attributes = "0xCF8:0xCFF";
    }
}
