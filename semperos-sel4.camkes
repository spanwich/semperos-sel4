/*
 * semperos-sel4.camkes -- CAmkES assembly for SemperOS on seL4
 *
 * Architecture:
 *   - VDTUService:    Virtual DTU control plane (endpoint configuration)
 *   - SemperKernel:   SemperOS kernel instance (kid=0)
 *   - VPE0:           Application VPE (test stub)
 *
 * Connection types:
 *   1. seL4RPCCall:     Config RPC (SemperKernel -> VDTUService)
 *   2. seL4SharedData:  Message ring buffers (point-to-point: kernel <-> VPE0)
 *   3. seL4Notification: Doorbell signaling for message arrival
 *
 * Pre-allocation strategy:
 *   CAmkES requires static declaration of all connections. DTU endpoints
 *   are created dynamically at runtime. We pre-allocate a pool of shared
 *   memory channels and notifications, then have the vDTU assign them to
 *   DTU endpoints as they are configured.
 *
 *   For the minimal prototype (1 kernel + 1 VPE):
 *   - 8 message channels: SemperKernel <-> VPE0
 *     (6 for SYSC_GATES + 1 for DEF_RECVEP + 1 spare)
 *   - 4 memory dataports: SemperKernel <-> VPE0
 *     (for DTU READ/WRITE memory endpoint operations)
 *   - 1 RPC connection:   SemperKernel -> VDTUService (config calls)
 *
 * Data path separation:
 *   The vDTU is control plane only -- it manages an endpoint table and
 *   assigns channels, but NEVER touches the data path memory. All
 *   seL4SharedData connections are point-to-point between kernel and VPE0.
 *   Direct notifications between kernel and VPE0 avoid routing signals
 *   through the vDTU.
 */

import <std_connector.camkes>;

/* Import the vDTU config interface */
procedure VDTUConfig {
    int config_send(in int target_pe, in int ep_id,
                    in int dest_pe, in int dest_ep, in int dest_vpe,
                    in int msg_size, in uint64_t label, in int credits);
    int config_recv(in int target_pe, in int ep_id,
                    in int buf_order, in int msg_order, in int flags);
    int config_mem(in int target_pe, in int ep_id,
                   in int dest_pe, in uint64_t addr, in uint64_t size,
                   in int dest_vpe, in int perm);
    int invalidate_ep(in int target_pe, in int ep_id);
    int invalidate_eps(in int target_pe, in int first_ep);
    int set_vpe_id(in int target_pe, in int vpe_id);
    int set_privilege(in int target_pe, in int priv);
    int wakeup_pe(in int target_pe);
    int get_ep_count();
};

/*
 * =========================================================================
 *  Component Definitions
 * =========================================================================
 */

component VDTUService {
    control;

    /* Config RPC: served to SemperKernel */
    provides VDTUConfig config;

    /*
     * The vDTU is control plane only. It does NOT have dataport access to
     * message channels or memory endpoints. It maintains an in-memory
     * endpoint table mapping (pe, ep) -> channel_index. The actual shared
     * memory is point-to-point between kernel and VPE0.
     */

    /* Control plane notifications: vDTU can wake kernel or VPE0 (wakeup_pe) */
    emits    Signal notify_kernel;
    emits    Signal notify_vpe0;

    /* Kernel signals vDTU when done (for coordination) */
    consumes Signal kernel_done;
}

component SemperKernel {
    control;

    /* Config RPC: calls vDTU to set up endpoints */
    uses VDTUConfig vdtu;

    /* Pre-allocated message channel dataports (shared with VPE0) */
    dataport Buf(4096) msgchan_kv_0;
    dataport Buf(4096) msgchan_kv_1;
    dataport Buf(4096) msgchan_kv_2;
    dataport Buf(4096) msgchan_kv_3;
    dataport Buf(4096) msgchan_kv_4;
    dataport Buf(4096) msgchan_kv_5;
    dataport Buf(4096) msgchan_kv_6;
    dataport Buf(4096) msgchan_kv_7;

    /* Pre-allocated memory endpoint dataports */
    dataport Buf(4096) memep_kv_0;
    dataport Buf(4096) memep_kv_1;
    dataport Buf(4096) memep_kv_2;
    dataport Buf(4096) memep_kv_3;

    /* Control plane: vDTU can wake kernel (for wakeup_pe) */
    consumes Signal vdtu_wakeup;

    /* Control plane: kernel signals vDTU when done */
    emits    Signal kernel_done;

    /* Data path: kernel signals VPE0 that a message is available */
    emits    Signal signal_vpe0;

    /* Data path: VPE0 signals kernel that a reply is available */
    consumes Signal signal_from_vpe0;
}

component VPE0 {
    control;

    /* Pre-allocated message channel dataports (shared with SemperKernel) */
    dataport Buf(4096) msgchan_kv_0;
    dataport Buf(4096) msgchan_kv_1;
    dataport Buf(4096) msgchan_kv_2;
    dataport Buf(4096) msgchan_kv_3;
    dataport Buf(4096) msgchan_kv_4;
    dataport Buf(4096) msgchan_kv_5;
    dataport Buf(4096) msgchan_kv_6;
    dataport Buf(4096) msgchan_kv_7;

    /* Pre-allocated memory endpoint dataports */
    dataport Buf(4096) memep_kv_0;
    dataport Buf(4096) memep_kv_1;
    dataport Buf(4096) memep_kv_2;
    dataport Buf(4096) memep_kv_3;

    /* Control plane: vDTU can wake VPE0 (for wakeup_pe) */
    consumes Signal vdtu_wakeup;

    /* Data path: kernel signals VPE0 that a message is available */
    consumes Signal signal_from_kernel;

    /* Data path: VPE0 signals kernel that a reply is available */
    emits    Signal signal_kernel;
}

/*
 * =========================================================================
 *  Assembly: wire everything together
 * =========================================================================
 */

assembly {
    composition {
        component VDTUService   vdtu;
        component SemperKernel  kernel0;
        component VPE0          vpe0;

        /*
         * Config RPC: kernel0 -> vdtu
         */
        connection seL4RPCCall config_rpc(from kernel0.vdtu, to vdtu.config);

        /*
         * Message channel dataports: kernel0 <-> vpe0 (point-to-point).
         * Each connection allocates one set of physical pages shared
         * between exactly two components. The vDTU does NOT access these.
         */
        connection seL4SharedData msgchan0(from kernel0.msgchan_kv_0,
                                           to vpe0.msgchan_kv_0);
        connection seL4SharedData msgchan1(from kernel0.msgchan_kv_1,
                                           to vpe0.msgchan_kv_1);
        connection seL4SharedData msgchan2(from kernel0.msgchan_kv_2,
                                           to vpe0.msgchan_kv_2);
        connection seL4SharedData msgchan3(from kernel0.msgchan_kv_3,
                                           to vpe0.msgchan_kv_3);
        connection seL4SharedData msgchan4(from kernel0.msgchan_kv_4,
                                           to vpe0.msgchan_kv_4);
        connection seL4SharedData msgchan5(from kernel0.msgchan_kv_5,
                                           to vpe0.msgchan_kv_5);
        connection seL4SharedData msgchan6(from kernel0.msgchan_kv_6,
                                           to vpe0.msgchan_kv_6);
        connection seL4SharedData msgchan7(from kernel0.msgchan_kv_7,
                                           to vpe0.msgchan_kv_7);

        /* Memory endpoint dataports: kernel0 <-> vpe0 */
        connection seL4SharedData memep0(from kernel0.memep_kv_0,
                                         to vpe0.memep_kv_0);
        connection seL4SharedData memep1(from kernel0.memep_kv_1,
                                         to vpe0.memep_kv_1);
        connection seL4SharedData memep2(from kernel0.memep_kv_2,
                                         to vpe0.memep_kv_2);
        connection seL4SharedData memep3(from kernel0.memep_kv_3,
                                         to vpe0.memep_kv_3);

        /*
         * Control plane notifications: vDTU -> kernel, vDTU -> VPE0
         * Used by wakeup_pe() to wake a PE from seL4_Wait().
         */
        connection seL4Notification vdtu_wake_kern(from vdtu.notify_kernel,
                                                    to kernel0.vdtu_wakeup);
        connection seL4Notification vdtu_wake_vpe0(from vdtu.notify_vpe0,
                                                    to vpe0.vdtu_wakeup);
        connection seL4Notification kern_done(from kernel0.kernel_done,
                                              to vdtu.kernel_done);

        /*
         * Data path notifications: kernel <-> VPE0 (direct, no vDTU)
         * The sender signals the receiver after writing to the ring buffer.
         */
        connection seL4Notification kern_to_vpe0(from kernel0.signal_vpe0,
                                                  to vpe0.signal_from_kernel);
        connection seL4Notification vpe0_to_kern(from vpe0.signal_kernel,
                                                  to kernel0.signal_from_vpe0);
    }

    configuration {
        /* vDTU runs at highest priority (handles config RPCs promptly) */
        vdtu.priority = 250;
        /* SemperKernel gets PE ID 0 */
        kernel0.priority = 200;
        /* VPE0 gets PE ID 2 â€” same priority as kernel for seL4_Yield() scheduling */
        vpe0.priority = 200;
    }
}
